/**
 * 
 */
package uk.ac.manchester.cs.pronto.io;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.semanticweb.owlapi.apibinding.OWLManager;
import org.semanticweb.owlapi.model.IRI;
import org.semanticweb.owlapi.model.OWLAxiom;
import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLClassExpression;
import org.semanticweb.owlapi.model.OWLDataFactory;
import org.semanticweb.owlapi.model.OWLEntity;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyChange;
import org.semanticweb.owlapi.model.OWLOntologyCreationException;
import org.semanticweb.owlapi.model.OWLOntologyIRIMapper;
import org.semanticweb.owlapi.model.OWLOntologyManager;

import uk.ac.manchester.cs.owlapi.modularity.ModuleType;
import uk.ac.manchester.cs.owlapi.modularity.SyntacticLocalityModuleExtractor;
import aterm.ATermAppl;

import com.clarkparsia.pellet.owlapiv3.PelletReasoner;
import uk.ac.manchester.cs.pronto.ConditionalConstraint;
import uk.ac.manchester.cs.pronto.Constants;
import uk.ac.manchester.cs.pronto.PABoxImpl;
import uk.ac.manchester.cs.pronto.PTBoxImpl;
import uk.ac.manchester.cs.pronto.ProbKnowledgeBase;
import uk.ac.manchester.cs.pronto.exceptions.OntologyLoadingException;

/**
 * <p>Title: KBStandaloneLoader</p>
 * 
 * <p>Description: 
 *  Loads probabilistic KB from a separate ontology with <pronto:certainty>
 *  axioms.
 *  NOTE: This class does assume that the classical part is an imported
 *  ontology
 * </p>
 * 
 * <p>Copyright: Copyright (c) 2007, 2008</p>
 * 
 * <p>Company: Clark & Parsia, LLC. <http://www.clarkparsia.com></p>
 * 
 * @author pavel
 */
public class KBStandaloneLoader implements ProntoLoader {

	private final String MODULE_IRI = "http://clarkparsia.com/pronto#module";
	/*
	 * Stores the logical URI of the classical part of the ontology
	 */
	private String m_classURI = null;
	/* 
	 * 
	 */
	public ProbKnowledgeBase load(String uri) throws OntologyLoadingException {

		OWLOntologyManager manager = OWLManager.createOWLOntologyManager();
		//Take everything before the last "/"
		OWLOntologyIRIMapper iriMapper = new BaseIRIMapper(uri.substring( 0, uri.lastIndexOf( '/' ) )); 

		manager.addIRIMapper( iriMapper );
		
		try {
			
			return load(manager.loadOntology( IRI.create( uri ) ));

		} catch( OWLOntologyCreationException e ) {

			e.printStackTrace();
			
			throw new OntologyLoadingException(e);
		}
	}
	
	public ProbKnowledgeBase load(OWLOntology ontology) throws OntologyLoadingException {
		
 
		OWLOntologyManager manager = OWLManager.createOWLOntologyManager();
		OWLOntology classOntology = null;
		PelletReasoner reasoner = null;
		ProbKnowledgeBase pkb = new ProbKnowledgeBase();
		
		m_classURI = null;

		Set<ConditionalConstraint> ccSet =	null;
		Map<ATermAppl, Set<ConditionalConstraint>> ccMap = null;
		//This map is used to keep auto generated class names
		Map<String, OWLClassExpression> nameMap = new HashMap<String, OWLClassExpression>();
		Set<OWLEntity> signature = new HashSet<OWLEntity>();
		//Load the classical part
		for( OWLOntology imported : ontology.getImports( ) ) {
			/*
			 * There should be exactly one imported ontology
			 * 
			 * Why??? There can be many. FIXME
			 */
			ccSet = ProntoLoaderUtils.loadDefaultConstraintsFromOWL(ontology,
			                                                        nameMap,
			                                                        signature,
			                                                        null,
			                                                        Constants.PRONTO_CLASS_AUTO_IRI,
			                                                        manager);
			ccMap = ProntoLoaderUtils.loadConcreteConstraintsFromOWL(	ontology,
																		nameMap,
																		signature,
																		null,
																		Constants.PRONTO_CLASS_AUTO_IRI,
																		manager);
			/*
			 * FIXME This module will not contain signatures of entailment queries, so those will fail!
			 * Update: any queries which involve extra signature will fail, e.g. CCSetAnalyzer tests
			 */
			classOntology = imported;//extractModule(manager, imported, signature);
			addAutoGeneratedClassNames(manager, classOntology, nameMap);
			
			reasoner = new PelletReasoner(classOntology, null);
			m_classURI = classOntology.getOntologyID().getOntologyIRI().toString();
			
			break;
		}

		if (null == m_classURI) { 
			/*
			 * Something went wrong, perhaps no classical ontology is imported
			 */
			String errMsg = ccSet != null && ccSet.size() > 0
				? "KBStandaloneLoader expects probabilistic ontology to import classical one"
				: "Ontology does not seem probabilistic at all";
			
			throw new OntologyLoadingException(null, errMsg);
		}

		PTBoxImpl ptbox = new PTBoxImpl(reasoner.getKB(), classOntology, ccSet );
		
		ptbox.setAutoGeneratedClasses( nameMap );
		pkb.setPTBox( ptbox );
		pkb.setPABox( new PABoxImpl(ccMap ) );
		ptbox.setID( ontology.getOntologyID().getOntologyIRI().toString() );
		
		pkb.preprocess();
		
		return pkb;
	}
	
	private OWLOntology extractModule(	OWLOntologyManager man,
										OWLOntology ont,
										Set<OWLEntity> signature) {
		
		SyntacticLocalityModuleExtractor extractor = new SyntacticLocalityModuleExtractor(man, ont, ModuleType.STAR);
		
		try {
			
			return extractor.extractAsOntology( signature, IRI.create(MODULE_IRI) );
			
		} catch( OWLOntologyCreationException e ) {
			
			throw new RuntimeException("Module extraction error", e);
		}
	}

	/*
	 * Declares auto generated class names in the ontology 
	 */
	private void addAutoGeneratedClassNames(OWLOntologyManager manager,
											OWLOntology ontology,
											Map<String, OWLClassExpression> nameMap) {
		
		OWLDataFactory factory = manager.getOWLDataFactory();
		List<OWLOntologyChange> changes = new ArrayList<OWLOntologyChange>();
		
		for (Map.Entry<String, OWLClassExpression> entry : nameMap.entrySet()) {
			
			OWLClass subClass = factory.getOWLClass( IRI.create(entry.getKey()) );
			OWLAxiom declAxiom = factory.getOWLEquivalentClassesAxiom( subClass, entry.getValue() );
			
			changes.addAll( manager.addAxiom( ontology, declAxiom ) );
		}
		
		manager.applyChanges( changes );
	}

	public String getClassicalOntologyURI() {
		
		return m_classURI;
	}

	public ProbKnowledgeBase load(OWLOntology classPart, OWLOntology probPart)	throws OntologyLoadingException {

		ProbKnowledgeBase pkb = new ProbKnowledgeBase(); 
		//This map is used to keep auto generated class names
		Map<String, OWLClassExpression> nameMap = new HashMap<String, OWLClassExpression>();
		Set<OWLEntity> signature = new HashSet<OWLEntity>();
		OWLOntologyManager manager = OWLManager.createOWLOntologyManager();
		
		Set<ConditionalConstraint> ccSet = ProntoLoaderUtils.loadDefaultConstraintsFromOWL(	probPart,
				nameMap,
				signature,
				null,
				Constants.PRONTO_CLASS_AUTO_IRI,
				manager);
		
		Map<ATermAppl, Set<ConditionalConstraint>> ccMap = ProntoLoaderUtils.loadConcreteConstraintsFromOWL( probPart,
				nameMap,
				signature,
				null,
				Constants.PRONTO_CLASS_AUTO_IRI,
				manager);		

		addAutoGeneratedClassNames(manager, classPart, nameMap);
		
		PelletReasoner reasoner = new PelletReasoner(classPart, null);//TODO Module extraction here, please
		PTBoxImpl ptbox = new PTBoxImpl( reasoner.getKB(), classPart,  ccSet );
		
		ptbox.setAutoGeneratedClasses( nameMap );
		pkb.setPTBox( ptbox );
		pkb.setPABox( new PABoxImpl( ccMap ) );
		ptbox.setID( probPart.getOntologyID().getOntologyIRI().toString() );
		
		pkb.preprocess();
		
		return pkb;
	}

}
